\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[left=2cm,top=1cm,right=3cm,bottom=1cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}


\begin{document}

\begin{center}\LARGE\bf
    Datatypes and Trees
\end{center}

\section{Exceptions}
In OCaml, \textit{run-time errors} are reported with \textit{exceptions}. An exception can be defined
for later use, with the syntax: \textbf{exception} \textit{name}. The exception can also accept arguments
of some specified type, using the syntax: \textbf{exception} \textit{name} \textbf{of} \textit{type}.
Such an exception is called with (\textit{name argument}); for example, the exception \texttt{(Invalid\_argument "\textit{string}")}
must take a single string as its argument. Raise an exception with the keyword \textbf{raise}. See
examples in the functions "take" and "drop", defined in the lists chapter.

It is also possible to \textit{handle} an exception with an \textit{exception handler}. Note that the types must be
consistent with the type of the function.
\begin{lstlisting}
    safe_divide : int -> int -> int

    let safe_divide x y =
      try x / y with
        Division_by_zero -> 0
\end{lstlisting}

\section{Datatypes}
It is possible to declare your own datatypes with the syntax \texttt{type \textit{name} = \textit{constructor1}
 of \textit{type1} | \textit{constructor2} of \textit{type2} | ...}, where \textit{constructors} are the possible
 forms that the type can take. The constructors must start with a capital letter. It is possible to pattern match on these, as with built-in types:
 \begin{lstlisting}
   type colour =
     Red
   | Green
   | Blue
   | RGB of int * int * int

   components : colour -> int * int * int

   let components c =
     match c with
       Red -> (255, 0, 0)
     | Green -> (0, 255, 0)
     | Blue -> (0, 0, 255)
     | RGB (r, g, b) -> (r, g, b)
 \end{lstlisting}
 This is analagous to pattern matching some expression to different integers.

 A type can be polymorphic; that is, a part of a type (called a \textit{type variable}) can vary. For example,
 \texttt{type 'a option = None | Some of 'a}. In words, a value of type \texttt{$\alpha$ option} is either nothing or something
 of type $\alpha$. This can be especially useful in exception handling, as we shall see below.

 A type can also be defined recursively. For example, \texttt{type 'a sequence = Nil | Cons of 'a * 'a sequence}.
 Note that this has a direct mapping onto the built-in list type, where \texttt{[]} is \texttt{Nil}, \texttt{[1]} is \texttt{Cons (1, Nil)} and \texttt{['a', 'b']} is \texttt{Cons ('a', Cons ('b', Nil))}
 etc. All the functions we defined using lists can easily be converted to ones using our newly defined sequence.

 Another example of a recursive type is set up below:
 \begin{lstlisting}
   type expr =
     Num of int
   | Add of expr * expr
   | Subtract of expr * expr
   | Multiply of expr * expr
   | Divide of expr * expr
   | Power of expr * expr

   evaluate : expr -> int
   evaluate_opt : expr -> int option

   let rec evaluate e =
   match e with
     Num x -> x
   | Add (e, e') -> evaluate e + evaluate e'
   | Subtract (e, e') -> evaluate e - evaluate e'
   | Multiply (e, e') -> evaluate e * evaluate e'
   | Divide (e, e') -> evaluate e / evaluate e'
   | Power (e, e') -> power (evaluate e) (evaluate e')

   let evaluate_opt e =
     try Some (evaluate e) with Division_by_zero -> None
 \end{lstlisting}
 Note that we have used our \texttt{option} type for error handling. Thus, 1 + 2 * 3 would be represented as
 \texttt{Add (Num 1, Multiply (Num 2, Num 3))} in the expr type.

 \section{Trees}
 A \textit{binary tree} is used to represent structures that branch. Let us define the \textit{data structure} as
 follows:
 \begin{lstlisting}
   type 'a tree =
     Br of 'a * 'a tree * 'a tree
   | Lf
 \end{lstlisting}
This is a polymorphic data structure where the branches hold a value and the left and right subtrees. A leaf occurs when there is no left and
no right subtree. Thus, a valid tree would be \texttt{Br (2, Br (1, Lf, Lf), Lf)}.

We shall now define various functions for trees.
\begin{lstlisting}
  size : 'a tree -> int
  total : int tree -> int

  let rec size tr =
    match tr with
      Br (_, l, r) -> 1 + size l + size r
    | Lf -> 0

  let rec total tr =
    match tr with
      Br (x, l, r) -> x + total l + total raise
    | Lr -> 0
\end{lstlisting}

The depth of a tree is the longest path from the root of the tree to a leaf.
\begin{lstlisting}
  max : int -> int -> int
  maxdepth : 'a tree -> int
  list_of_tree : 'a tree -> 'a list
  tree_map : ('a -> 'b) -> 'a tree -> 'b tree

  let max x y =
    if x > y then x else y

  let rec max_depth tr =
    match tr with
      Br (_, l, r) -> 1 + max (maxdepth l) (maxdepth r)
    | Lf -> 0

  let rec list_of_tree tr =
    match tr with
      Br (x, l, r) -> list_of_tree l @ [x] @ list_of_tree r
    | Lf -> []

  let rec tree_map f tr =
    match tr with
      Br (x, l, r) -> Br (f x, tree_map f l, tree_map f r)
    | Lf -> Lf
\end{lstlisting}

We shall now discuss a more specific kind of tree called a \textit{binary search tree}. This is a tree such that all
branches with values smaller than any given branch are to the left of said branch and all branches with values larger than
a given branch are to the right of said branch. It can be used to implement a dictionary with more efficient lookup times (O(log n) instead
of O(n)).
\begin{lstlisting}
  lookup : ('a * 'b) tree -> 'a -> 'b option
  insert : ('a * 'b) tree -> 'a -> 'b -> ('a * 'b) tree
  tree_of_list : 'a list -> 'a tree

  let rec lookup tr k =
    match tr with
      Lf -> None
    | Br ((k', v'), l, r) ->
        if k = k' then Some v
        else if k < k' then lookup l k
        else lookup r k

  let rec insert tr k v =
    match tr with
      Lf -> Br ((k, v), Lf, Lf)
    | Br ((k', v'), l, r) ->
        if k = k' then Br ((k, v), l, r)
        else if k < k' then Br ((k', v'), insert l k v, r)
        else Br ((k', v'), l, insert r k v)

  let rec tree_of_list l =
    match l with
      [] -> Lf
    | (k, v)::t -> insert (tree_of_list t) k v
\end{lstlisting}
Note that \texttt{tree\_of\_list} can be implemented more efficiently using tail recursion.

\textit{Strings} are sequences of characters enclosed by double quotes, with the built-in type \textbf{string}.

\end{document}
