\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[left=2cm,top=1cm,right=3cm,bottom=1cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}


\begin{document}

\begin{center}\LARGE\bf
    Functions as Values
\end{center}

When making larger programs, it is necessary to reuse other programs. There are many ways of doing this.

It is possible to pass a function to another function as an argument. For example, the function \texttt{map}
below applies function f to every element in list l.
\begin{lstlisting}
    map : ('a -> 'b) -> 'a list -> 'b list

    let rec map f l =
      match l with
        [] -> []
      | h::t -> f h :: map f t
\end{lstlisting}

It is also possible to use a function within another function without assigning a name in the namespace to the argument function.
We call this type of function an \textit{anonymous function}. The syntax is
\texttt{fun name -> \textit{expression}}. This can be used when a function is only applied in one place and is
short. For example, below we define a function that returns true for an element if it's even.
\begin{lstlisting}
    evens : int list -> bool list

    let evens l =
      map (fun x -> x mod 2 = 0) l
\end{lstlisting}

OCaml allows you to convert an operator into a function with the syntax \texttt{( \textit{operator} )}. For example,
\texttt{( <= ) 3 4} has the value \texttt{true} and \texttt{( + ) 3 4} has the value \texttt{7}.

\section{Partial Application}
In reality, functions that take multiple arguments are really multiple single argument functions applied to
each other. That is, a function \text{f a b} has type $\alpha \rightarrow \beta \rightarrow \gamma$, which we can write as
$\alpha \rightarrow (\beta \rightarrow \gamma)$. Thus it takes an argument of type $\alpha$ and returns a function of type
$\beta \rightarrow \gamma$, which in turn takes an argument of $\beta$ and returns a value of type $\gamma$. This can be written
explicitly as \texttt{let f = fun a -> fun b -> ...} instead of just \texttt{let f = ...}.

As a result, it is possible to apply fewer than the total number of arguments to a function. This is called \textit{partial
application}. We now introduce various examples to demonstrate this.

The simplest example is \texttt{let add x y = x + y}. If we write \texttt{let f = add 6}, f is now a function that
adds 6. Notice that add has type int -> int -> int and f (and by extension add 6) has type int -> int.

Recall that it is possible to produce a function from an operator with the syntax \texttt{( / )}. This fact can be
used in conjunction with partial application to create, for example, a function which returns 2 divided by its input:
\texttt{let fun = ( / ) 2}. This can be applied to all elements of a list using map.

Consider a function that maps a function over a list of lists:
\begin{lstlisting}
  mapl : ('a -> 'b) -> 'a list list -> 'b list list

  let rec mapl f l =
    match l with
      [] -> []
    | h::t -> map f h :: mapl f t
\end{lstlisting}
This can be rewritten using partial application: \texttt{let mapl f l = map (map f) l} or even \texttt{let
mapl f = map (map f)}. In this case, \texttt{map (map f)} has type $\alpha$ list list -> $\beta$ list list.

Recall the member function, which checks if some value is in a given list:
\begin{lstlisting}
  member : 'a -> 'a list -> bool

  let rec member n l =
    match l with
      [] -> false
    | h::t -> n = h || member n t
\end{lstlisting}
We want to write a similar function that checks if some element is in every list in a list of lists.
We can solve this using partial application of member. \texttt{member x} will have type $\alpha$ list -> bool
so \texttt{map (member x)} has type $\alpha$ list list -> bool list. Thus,
\begin{lstlisting}
  member_all : 'a -> 'a list list -> bool

  let member_all x ls =
    let booleans = map (member x) ls in
      not (member false booleans)
\end{lstlisting}.

If we wanted to make a function which shortens all lists in a list of lists by a given length, we can do the following:
\begin{lstlisting}
  new_len : int -> 'a list -> 'a list
  truncate : int -> 'a list list -> 'a list list

  let new_len n l =
    try take n l with
      Invalid_argument _ -> l

  let truncate n l =
    map (new_len n) l
\end{lstlisting}

\end{document}
