\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage[left=2cm,top=1cm,right=3cm,bottom=1cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}


\begin{document}

\begin{center}\LARGE\bf
    Lists
\end{center}

\section{Pattern-matching}
Pattern matching allows you to select conditions neatly, without the need for many if statements. The
syntax is most clearly seen through an example:
\begin{lstlisting}
factorial : int -> int

let rec factorial a =
  match a with
    1 -> 1
  | _ -> a * factorial (a - 1)
\end{lstlisting}
The pattern $\_$ is used as a "wild card" as it can match anything. OCaml will warn you if your list of pattens is not
exhaustive. Note that all of the expressions that the patterns are matched to must have the same type and
thus, this is the type of the whole expression.

\section{Making Lists}
A \textit{list} is an ordered collection of zero or more elements of the same type. They are denoted by enclosing the elements in
square brackets, separated by semicolons, for example: \texttt{[1; 2; 3; 4; 5]}. If the list isn't empty(that is, it
doesn't contain no elements), it can be decomposed into a head (the first element) and a tail (a list containing the rest of the elements).
If the list only has one element, the tail is the empty list.
The \textit{cons} operator "\texttt{::}" adds an element to the front of a list; it can be used to separate a list \texttt{l}
into its head and tail \texttt{h::t}. This is especially useful when pattern matching as it allows us to separate
a list into its contents, for example:
\begin{lstlisting}
  sum : int list -> int
  let rec sum l =
    match l with
      [] -> 0
    | h::t -> h + sum t
\end{lstlisting}

We can separate a list into even more elements as a::(b::t) is the same as a::b::t. We can access any element of the
list in this way (although practically we wouldn't want to decompose it much more in this way). Thus, cons can distinguish lists of
specific lengths or with particular contents (for example, a list that can be written as a::b::t must contain at least two
elements).

The similar \textit{append} operator \texttt{@} can combine two lists together. This is proportional to the length of the left list,
while cons is constant time.

If a function works regardless of the type of its arguments, it is called \textit{polymorphic}. For example, the following length
function will find the length of the list input, regardless of the type of elements this list contains. This list has type \texttt{$\alpha$ list} as
a result.
\begin{lstlisting}
  length : 'a list -> list

  let rec length l =
    match l with
      [] -> 0
    | h::t -> 1 + length t
\end{lstlisting}
Conversely, the sum function defined above is not polymorphic as it only operates over lists of type int list. A list can have
other lists as its elements, in which case its type will be \texttt{$\alpha$ list list}.

We shall now define some useful functions for manipulating lists:
\begin{lstlisting}
  take : int -> 'a list -> 'a list
  drop : int -> 'a list -> 'a list

  let rec take n l =
    if n = 0 then [] else
      match l with
        h::t -> h :: take (n - 1) t

  let rec drop n l =
    if n = 0 then l else
      match l with
        h::t -> drop (n - 1) t
\end{lstlisting}
Note that these pattern matches are not exhaustive and so will fail if you try to take or drop more elements than the list
contains.

We shall now discuss a very powerful form of recursion called \textit{tail recursion}. Often, recursion results in
large expressions being built up (that is, many function calls on the stack), which can be inefficient as it is related to the
length of the argument. Tail recursion
bypasses this by using an accumulator. By passing an extra argument, we can store extra information at each function
call. This allows us to perform calculations that are unrelated to the length of the argument. Here is an example of
such a recursive function which reverses a list (note that the obvious way using \texttt{@} would be inefficient - quadratic in time).
When using \texttt{h::t} as an argument in a function, remember to enclose it in brackets.
\begin{lstlisting}
  rev : 'a list -> 'a list-> 'a list

  let rec rev_inner a l =
    match l with
      [] -> a
    | h::t -> rev_inner (h :: a) t

  let rev l = rev_inner [] l
\end{lstlisting}


\end{document}
